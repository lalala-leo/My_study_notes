# 07-数据库运维



## 01-mysql的安装与启动

### 安装流程

```bash
打包软件发送到db-51

# 解压安装包
tar -zxf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz 

# 创建软连接
ln -s /opt/mysql-5.7.28-linux-glibc2.12-x86_64 /opt/mysql

# 配置PATH
echo "export PATH=$PATH:/opt/mysql/bin" >> /etc/profile
source /etc/profile

# 删除mariadb的依赖，删除默认配置文件
yum remove mariadb-libs.x86_64  -y
rm -f /etc/my.cnf

# 装mysql5.7特有的依赖包
yum install libaio-devel -y

# 创建数据目录，
# 准备mysql的数据目录，授权用户
useradd -s /sbin/nologin -M mysql
mkdir -p /linux0224/
mkdir -p /linux0224/mysql_3306/

# 授权
chown -R mysql.mysql /linux0224/
chown -R mysql.mysql /linux0224/mysql_3306/
chown -R mysql.mysql /opt/mysql*

#检查
ls -ld  /linux0224 /linux0224/mysql_3306/  /opt/mysql*

# 此时自建的mysql目录，没有输数据，mysql 无法使用，初始化生成mysql默认库的数据源 ，用户等信息，即可启动
# mysqld 服务端命令，启动，初始化，都用的这个
# --basedir mysql二进制命令装再哪了，主程序目录
# --datadir 数据目录初始到哪
mysqld --initialize-insecure --user=mysql --basedir=/opt/mysql --datadir=/linux0224/mysql_3306/


```



### 配置文件

```bash
初始化完毕后，有配置文件即可正确启动，告诉 my.cnf
mysqld的数据源目录在哪，日志写入到哪等


# /etc/my.cnf 默认mysql会去读这个，不指定，也读这个

# [mysqld] 服务端会读取的配置
# [mysql]  再机器本地，执行mysql命令，客户端读取的配置 
# socket 本地进程套接字文件，用于mysql客户端再本地区链接


cat >/etc/my.cnf <<'EOF'

[mysqld]
port=3306
user=mysql
basedir=/opt/mysql
datadir=/linux0224/mysql_3306/
socket=/tmp/mysql.sock

[mysql]
socket=/tmp/mysql.sock
EOF

```



### 启动脚本

```bash
复制自带脚本即可

cp /opt/mysql/support-files/mysql.server /etc/init.d/mysqld

```



### 启动mysql，修改密码

```bash
# 启动mysql(/etc/init.d/mysqld)
systemctl daemon-reload
systemctl start mysqld
systemctl status mysqld

# mysql改密码
mysql -uroot -p

set password for root@localhost = password('linux0224');

```



### mysql多实例

```bash
# 创建数据目录
mkdir -p  /linux0224/mysql_3307

mkdir -p  /linux0224/mysql_3308

chown -R mysql.mysql /linux0224/*

# 初始化数据
mysqld --initialize-insecure --user=mysql --basedir=/opt/mysql --datadir=/linux0224/mysql_3307/

mysqld --initialize-insecure --user=mysql --basedir=/opt/mysql --datadir=/linux0224/mysql_3308/

# 创建配置文件
cat >/etc/mysql_3307.cnf <<'EOF'
[mysqld]
port=3307
user=mysql
basedir=/opt/mysql
datadir=/linux0224/mysql_3307/
socket=/linux0224/mysql_3307/mysql.sock
log_error=/linux0224/mysql_3307/mysql.log
EOF


cat >/etc/mysql_3308.cnf <<'EOF'
[mysqld]
port=3308
user=mysql
basedir=/opt/mysql
datadir=/linux0224/mysql_3308/
socket=/linux0224/mysql_3308/mysql.sock
log_error=/linux0224/mysql_3308/mysql.log
EOF


```



#### 多实例启动脚本

生成 3307 和3308即可

```bash
cat > /linux0224/3307.sh <<'EOF'

port="3307"
mysql_user="mysql"
Cmdpath="/opt/mysql/bin"
# socket用于判断程序是否运行
# 程序运行中，该socket文件存在
# 进程挂了，socket文件自动消失

myqsl_socket="/linux0224/mysql_${port}/mysql.sock"
# 定义路径，mysql进程启动后，一个存储该进程pid号码的文件在哪
mysqld_pid_file_path=/linux0224/mysql_${port}/mysqld_${port}.pid

# 启动mysqld服务端的入口命令
start(){
if [ ! -e "$mysql_socket" ];then
	printf "Starting Mysql...\n"
	# mysql的启动逻辑
	# mysqld_safe 脚本 >  mysqld 脚本 > 运行mysql进程
	
	/bin/sh ${Cmdpath}/mysqld_safe --defaults-file=/etc/mysql_${port}.cnf --pid-file=$mysqld_pid_file_path 2>&1 > /dev/null &
	sleep 3
else
    printf "MySQL is running...\n"
    exit 1
fi	
}

stop(){
    if [ ! -e "$mysql_sock" ];then
        printf "MySQL is stopped...\n"
        exit 1
    else
        printf "Stoping MySQL...\n"
        mysqld_pid=`cat "$mysqld_pid_file_path"`
    if (kill -0 $mysqld_pid 2>/dev/null)
        then
        kill $mysqld_pid
        sleep 2
        fi
    fi
}

restart(){
    printf "Restarting MySQL...\n"
    stop
    sleep 2
    start
}



case "$1" in
start)
    start
;;
stop)
    stop
;;
restart)
    restart
;;
*)
    printf "Usage: /data/${port}/mysql{start|stop|restart}\n"
esac
EOF

```



#### 启动多实例

```bash
netstat -tunlp|grep mysql

bash /linux0224/3307.sh start
bash /linux0224/3308.sh start
```



#### 设置多实例密码并登录

```bash
mysql -uroot -p -S /tmp/mysql.sock
set password for root@localhost = password('linux3306');

mysql -uroot -p -S /linux0224/mysql_3307/mysql.sock
set password for root@localhost = password('linux3307');

mysql -uroot -p -S /linux0224/mysql_3308/mysql.sock
set password for root@localhost = password('linux3308');

```



#### 验证port登录

```bash
mysql -hlocalhost -P3306 -uroot -plinux3306 -e "show global variables like 'port';"

```



## 02-mysql运维核心基础



### 1.启动，关闭mysql原理

```bash
管理3306实例的脚本逻辑顺序
脚本放在了 /etc/init.d/mysqld
可以用多种方式使用该脚本

1. 给脚本添加执行权限
/etc/init.d/mysqld start

2. 该方式等于
service mysqld start 

3. centos7上建议写法
systemctl start mysqld

4. service和systemctl命令都是去读取/etc/init.d/目录下的脚本mysqld脚本文件

```



#### mysqld_safe和mysqld区别

```bash
yum install psmisc -y

mysqld_safe作用


1. mysql官方启动脚本，是以执行mysqld_safe为入口，其实mysqld_safe也是个shell脚本，调用了myqsld命令启动服务

2.mysqld_safe脚本设置运行环境，如以守护进程运行
3.mysqld_safe检测mysqld运行状态
4.mysqld_safe检测mysqld进程运行信息，写入 mysql实例目录下的hostname.err文件
5.以及mysqld_safe会读取my.cnf配置文件的[mysqld],[mysqld_safe]等配置


mysqld作用

mysqld是mysql的核心程序，用于管理mysql的数据库文件，以及用户执行的SQL请求
mysqld读取my.cnf中 [mysqld]配置
```



#### 启动命令的区别

```bash
3306
复制mysql的官方脚本  

入口 >>>>>>   /etc/init.d/mysqld

↓

/opt/mysql/bin/mysqld_safe

↓

mysql主程序命令
/opt/mysql/bin/mysqld
```



### 2.关闭mysql

#### 脚本关闭

```bash
该实例用什么脚本启动就用什么脚本关闭
3307 3308

bash /linux0224/3307.sh stop
```



#### 命令关闭

```bash
更推荐用这个吧
# 先登录具体实例，然后再关闭
# 3308

mysql> shutdown;
```



#### 特殊情况下，不建议用这个操作

```bash
直接用kill  pkill  killall

kill pid   # 除非进程卡死，无任何解决办法，再去 kill -9 pid 数据丢失，数据写入，事务提交，确认数据写入到磁盘，写入到日志

pkill   进程名

killall     进程名

直接杀死mysqld的玩法，可能导致下次mysql无法启动，日志会有报错信息
```





### 3.自定义mysqld服务管理脚本

```bash
# 1.写mysql的运行脚本
如 /linxu0224/3307.sh     
/linxu0224/3307.sh  start
/linxu0224/3307.sh  stop
/linxu0224/3307.sh  restart


# 2.写入 /etc/init.d/mysqld
/etc/init.d/mysqld
service 
systemctl 
管理


# 3.centos7下，写服务管理脚本，参考 ，network脚本等写就行

```



### 4.配置文件模板

```bash
[mysqld] # 服务端标签
port=3306    # 端口
server_id # 主机编号，用于主从复制
user=mysql    # 内置运行用户
basedir=/opt/mysql    # 软件目录
datadir=/linux0224/mysql_3306    # 数据目录
socket=/tmp/mysql.sock    # 套接字文件路径

[mysql]
socket=/tmp/mysql.sock    # mysql客户端连接数据库，默认读取的socket文件路径


配置语法
[server]                服务端读取的配置
[mysqld]                mysqld进程读取的配置
[mysqld_safe]        mysqld_safe脚本会加载的配置


客户端配置参数
[mysql]        客户端命令读取的设置
[client]    所有本地客户端读取的设置
[mysqldump]    备份命令读取的设置

```



### 5.远程连接管理学习grant语句

#### 本地连接

```bash
# 授权语句，创建一个用户，只允许本地连接

# 也能实现创建一个用户的作用

grant 权限  on 库.表 to 用户名@'允许登录的网段' identified by '远程登录的用户密码';

# 注意，写localhost 和127.0.0.1是不一样的


# 创建laoliu用户，只允许再机器本地登录mysql 3307实例，给与最大权限，可以增删改查所有库表

# 先登录
mysql -uroot -plinux3307 -S /linux0224/mysql_3307/mysql.sock 

grant all privileges on *.* to laoliu@'127.0.0.1' identified by 'laoliu666';

```



查看用户表

```bash
# 1.先登录
mysql -uroot -plinux3307 -S /linux0224/mysql_3307/mysql.sock 

# 2.进入mysql库，查看库下所有的表
show databases;

use mysql;

select database();

show tables;

show tables from mysql;

select user,host,authentication_string from mysql.user;


# 3.登录测试
mysql -ulaoliu -plaoliu666 -h127.0.0.1 -P3307


mysql -ulaoliu -plaoliu666 -S /linux0224/mysql_3307/mysql.sock 

[root@db-51 ~]#mysql -ulaoliu -plaoliu666 -S /linux0224/mysql_3307/mysql.sock 
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 1045 (28000): Access denied for user 'laoliu'@'localhost' (using password: YES)


# 报错登录localhost不可以，再加一条记录即可
grant all privileges on *.* to laoliu@'loacalhost' identified by 'laoliu666';

FLUSH PRIVILEGES;

mysql> select user,host,authentication_string from mysql.user;
+---------------+------------+-------------------------------------------+
| user          | host       | authentication_string                     |
+---------------+------------+-------------------------------------------+
| root          | localhost  | *19A77E0F06928E313B68F2AAB7756D508846258B |
| mysql.session | localhost  | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| mysql.sys     | localhost  | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE |
| laoliu        | 127.0.0.1  | *F855FFDB396A372CBC77794CFEFB33779D20D86B |
| laoliu        | loacalhost | *F855FFDB396A372CBC77794CFEFB33779D20D86B |
+---------------+------------+-------------------------------------------+
5 rows in set (0.00 sec)


mysql -ulaoliu -plaoliu666 -S /linux0224/mysql_3307/mysql.sock

```



#### 远程连接

##### 关于登录的方式选择

```bash
1. 本地登录，建议用socket去链接，或者ip:port也行
2. 远程登录，只能走IP:port了
```



##### 远程登陆

```bash
其他机器，登录10.0.0.51的3307的数据库实例
# 只允许laoliu用户在 10.0.0.0~255 网段登录，有最大的权限

# 授权语句只能用root去操作

# % 百分号表示一个任意匹配的意思
grant all privileges on *.* to laoliu@'10.0.0.%' identified by 'laoliu666';

#查询mysql的用户表的信息，当前mysql实例，有哪些用户信息
select user,host from mysql.user;

# 再创建一个用户laoba,只允许在内网172网段登录mysql
grant all privileges on *.* to laoba@'172.16.1.%' identified by 'laoba666';

```



##### 试试远程去登录

```bash
# laoliu用户，在10网段的机器登录

# 10.0.0.xxx的机器，能和这个 10.0.0.51:3307确保通信就行


# laoba用户，只允许再172的内网环境登录 
#172.16.1.xx 的机器，和  172.16.1.51:3307


# 查看mysql 3307 服务端
[root@db-51 ~]#netstat -tunlp | grep 3307
tcp6       0      0 :::3307                 :::*                    LISTEN      22917/mysqld  

# :::3307可以理解为0.0.0.0:3307
# 也就是10.0.0.51:3307和172.16.1.51:3307


[root@web-7 /etc/init.d]#mysql -ulaoba -plaoba666 -h172.16.1.51 -P3307

mysql> select user,host from mysql.user;
+---------------+------------+
| user          | host       |
+---------------+------------+
| laoliu        | 10.0.0.%   |
| laoliu        | 127.0.0.1  |
| laoba         | 172.16.1.% |
| laoliu        | localhost  |
| mysql.session | localhost  |
| mysql.sys     | localhost  |
| root          | localhost  |
+---------------+------------+
7 rows in set (0.00 sec)


```



##### navicat图形化访问



![image-20241016235028834](F:\学习笔记\devops\learn_info\pic\image-20241016235028834.png)



![image-20241016235429325](F:\学习笔记\devops\learn_info\pic\image-20241016235429325.png)



```bash
[root@db-51 ~]#netstat -an | grep 3307
tcp6       0      0 :::3307                 :::*                    LISTEN     
tcp6       0      0 10.0.0.51:3307          10.0.0.1:61184          ESTABLISHED
tcp6       0      0 10.0.0.51:3307          10.0.0.1:61185          ESTABLISHED
unix  2      [ ACC ]     STREAM     LISTENING     110957   /linux0224/mysql_3307/mysql.sock

```





### 6.mysql用户管理

#### 6.1 用户说明

```bash
linux 用户
- 登录系统
- 管理文件


mysql 用户
- 登录mysql
- 管理mysql的库、表，能管理哪些库，表，以及能做什么事
都看grant语句给的权限了
```



#### 6.2 远程登录白名单语法

```bash
mysql 用户授权语法

远程登录，不在服务端的机器上去登

服务端 10.0.0.51:3307

用10.0.0.7机器，去登 51



用户名@'网段白名单'

# 语法
yuchao@'localhost'  yuchao可以在本地登录（ip:3306），以及socket

yuchao@'10.0.0.10'  yuchao只能在10.0.0.10这个客户端登录
yuchao@'10.0.0.%'   yuchao只能在10.0.0.xx/24网段登录
yuchao@'10.0.0.5%'  yuchao只能在10.0.0.50~59 登录

yuchao@'%'  yuchao可以在任意地址登录该mysql服务端
yuchao@'db-51'   基于主机名的登录限制

```



#### 6.3 用户管理

##### 查看mysql用户列表

```bash
# 查看mysql库下的user表的数据
# user 用户名
# host 允许登录的网段白名单
# authentication_string 验证字符串，密码的意思（加密显示的）


select user,host,authentication_string from mysql.user;

```

##### 创建用户

```bash
create user laoyi@'localhost' identified by 'laoyi666';

# 明确区分，关键字和用户数据

CREATE USER laoyi@'10.0.0.7' IDENTIFIED BY  'laoyi123';


```

##### 修改用户密码，root去修改

```bash
# root权限最大的，修改表数据了，修改语法是基于

# 区分关键字表示
# 修改用户laoyi的密码laoyi666

ALTER USER laoyi@'10.0.0.7' IDENTIFIED BY 'laoyi666'

# 查看user
select user,host,authentication_string from mysql.user;
```

##### 删除用户

```bash
drop user laoyi@'10.0.0.7';
DROP USER laoyi@'10.0.0.7';
```





### 7.grant授权管理

```bash
grant  给与的权限1,权限2,权限3  on 库.表  to 用户名@允许登录的网段规则  indentified by '密码'；

```



#### 授权实践

root默认不允许远程登录，给与权限，允许远程登录

```mysql
GRANT ALL PRIVILEGES on *.* to root@'%'  IDENTIFIED BY 'linux666';
```



给一个普通开发者leo01的账户权限，只能增删改查基本操作，且限定某个数据库，且只允许在内网环境连接。

```mysql
select,update,delete,insert

dev01 库

172.16.1.%

CREATE DATABASE dev01;

show databases;

GRANT SELECT,UPDATE,DELETE,INSERT ON dev01.* TO leo01@'172.16.1.%' IDENTIFIED BY 'leo666';

select user,host from mysql.user;

```



#### 查看具体用户的权限

```mysql
show grants # 查看当前用户的权限信息

mysql> show grants;
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION |
| GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION        |
+---------------------------------------------------------------------+


show grants for 用户@'网段';  #查询具体用户的权限

show grants for leo01@'172.16.1.%';

```



#### 回收权限

```mysql
# grant授权的语句

# 移除leo01  对dev01库下的所有表的 delete 权限

# 大写语法
REVOKE DELETE ON dev01.* from leo01@'172.16.1.%';
show grants for leo01@'172.16.1.%';

# 移除所有权限，针对dev01这个库
REVOKE all ON dev01.* from leo01@'172.16.1.%';
show grants for leo01@'172.16.1.%';

```





## 03-sql篇

### 01.导入，恢复mysql数据的方式

```bash
# mysql的备份，恢复
就是俩过程
1. 备份，将当前的数据库，表，数据，全部导出为一个sql的文件

2. 恢复，原理就是，准备 一个文件，，里面是大量的，创建库，创建表，插入数据的SQL语句而已，重新执行一下

# 1.bash命令行直接导入
mysql -uroot -plinux3306  <  /root/all_world.sql 

# 2.mysql环境中，用source语句去导入
mysql -uroot -plinux3306 -S /tmp/mysql.sock

source /root/test_db-master/employees.sql;

#改了下远程登陆的账号密码
update mysql.user set authentication_string=PASSWORD('root001') where user='root' and host='%';

```





```
CREATE TABLE dev01.t2 (`id` int(11) NOT NULL,`name` varchar(255) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```





## 04-备份与日志

### 备份工具

#### 逻辑备份

把数据库、表，以SQL语句的形式，输出为文件的备份过程，这种方式称之为逻辑备份。

但是这种方式效率并不高，以SQL导出，在海量数据下，例如几十G的场景，备份、恢复的时间都会过长。

因此还会有其他备份方案。

```bash
mysqldump 
mysqlbinlog
mydumper
binlog2sql
```



#### 物理备份

```bash
1. 工具使用，https://www.percona.com/software/mysql-database/percona-xtrabackup

2.直接shell+crontab备份整个mysql数据目录
```



### mysqldump备份

- 只备份某些库
- 只备份某些表
- 以及只要表结构，不要表数据
- 结构，数据都要，全量备份等

```bash
mysqldump备份语法

Mysqldump -u用户名 -p密码 参数 数据库名 > 数据备份文件

mysql自带的备份工具，可以实现本地备份，远程备份


mysqldump命令备份过程，实际上是把数据库、表，以SQL语句的形式，输出为文件的备份过程，这种方式称之为逻辑备份。

```



#### mysqldump连接参数

```bash
-u mysql用户名
-p mysql用户密码
-S mysql本地socket文件
-h 指定主机地址
-P 指定mysql端口
```



#### 全量备份

对当前数据库实例，导出，所有的库，表，以及数据，转储为SQL文件

对这个文件进行导入执行。

```bash
--all--databases，-A   转储所有数据库中的所有表

mysqldump -uroot -plinux3306 --all-databases > /opt/mysql-3306.sql

```



#### 制定3306备份某个库下的某个表

```bash
mysqldump -uroot -plinux3306 employees salaries > /opt/cust_info.sql

1. 删除salaries表
2. 创建salaries表结构 ，定义好字段
3. insert插入数据

# 3307实例单独导入某个表数据

# 方式1，导入数据
mysql> create database test_employees;

mysql> use test_employees;

mysql> source /opt/cust_info.sql

# 方式2，命令行，指定库导入
mysql -S /linux0224/mysql_3307/mysql.sock test_employees < /opt/cust_info.sql


```



#### 某个库下的多个表

```bash
mysqldump -uroot -plinux3306 employees dept_emp dept_manager > /opt/cust_info_all.sql


mysql -S /linux0224/mysql_3307/mysql.sock test_employees < /opt/cust_info_all.sql

```



#### 多个库

```bash
--database，-B
转储几个数据库。

通常情况，mysqldump将命令行中的第1个名字参量看作数据库名，后面的名看作表名。
使用该选项，它将所有名字参量看作数据库名。


-B可以跟上多个数据库名，同时备份多个库

尽量结合gzip命令压缩

mysqldump -uroot -plinux3306 -B employees dev01 > /opt/employees_dev01.sql

```



#### 只要表结构，不要数据

```bash
# --no-data参数, -d

# 语法

mysqldump -uroot -plinux3306 -d employees salaries > /opt/emp_salaries_nodata.sql

```



#### 只要表数据，不要结构

```bash
# --no-create-info，-t

# 语法
# 还是遵循mysqldump的 默认语法  库  表1  表2 表3

mysqldump -uroot -plinux3306 -t employees salaries > /opt/emp_salaries_nocreateinfo.sql


# 数据导入，文件，可能比较大，建议压缩 
mysqldump -uroot -plinux3306 -t employees salaries |gzip > /opt/emp_salaries_nocreateinfo.sql.gz


```





## 05-binlog日志篇

binlog是mysql一大重点，Binlog是一个二进制格式的文件，用于`记录用户对数据库更新的SQL语句信息`

例如`更改数据库库表`和`更改表内容的SQL语句`都会记录到binlog里，但是对库表等内容的查询则不会记录到日志中。

```
记录
DML，insert update，delete
DDL，create drop，alter，truncate
DCL，grant revoke
```



### 配置binlog

默认是没开启binlog功能的

```bash
mysql> show variables like '%log_bin%';
+---------------------------------+-------+
| Variable_name                   | Value |
+---------------------------------+-------+
| log_bin                         | OFF   |
| log_bin_basename                |       |
| log_bin_index                   |       |
| log_bin_trust_function_creators | OFF   |
| log_bin_use_v1_row_events       | OFF   |
| sql_log_bin                     | ON    |
+---------------------------------+-------+
6 rows in set (0.00 sec)

```



### 开启binlog

```bash
只需要修改配置文件，加入开启 log_bin的参数即可，就是永久生效的了

server_id=100
log_bin=/mysql_log/log_bin_3306/mysql-log-bin

# 最终配置
cat /etc/my.cnf 
 
[mysqld]
server_id=100
log_bin=/mysql_log/log_bin_3306/mysql-log-bin
port=3306
user=mysql
basedir=/opt/mysql
datadir=/linux0224/mysql_3306/
socket=/tmp/mysql.sock

[mysql]
socket=/tmp/mysql.sock



# 重启mysqld
mkdir -p /mysql_log/log_bin_3306/
chown -R mysql.mysql /mysql_log/
systemctl restart mysqld


# 登录查看变量
mysql> show variables like '%log_bin%';
+---------------------------------+---------------------------------------------+
| Variable_name                   | Value                                       |
+---------------------------------+---------------------------------------------+
| log_bin                         | ON                                          |
| log_bin_basename                | /mysql_log/log_bin_3306/mysql-log-bin       |
| log_bin_index                   | /mysql_log/log_bin_3306/mysql-log-bin.index |
| log_bin_trust_function_creators | OFF                                         |
| log_bin_use_v1_row_events       | OFF                                         |
| sql_log_bin                     | ON                                          |
+---------------------------------+---------------------------------------------+
6 rows in set (0.00 sec)


```



### binlog内容的格式

```bash
1. 事件描述
时间戳
server_id
加密方式

开始位置 start_pos
结束位置 end_pos

mysql里面的数据操作，都是事务性，被mysql以 开始-结尾 做了一个记录

create database  d1; 从开始 到结束，都被mysql  数字号，记录位置


2.事件内容
修改类的操作，SQL语句，数据行的变化


重点，使用binlog主要关注
start_pos
end_pos
事件内容
```



### 查看binlog日志文件情况

```bash
# 查看当前数据库实例，用哪个日志文件记录 SQL中。
show binary logs;

mysql> show binary logs;
+----------------------+-----------+
| Log_name             | File_size |
+----------------------+-----------+
| mysql-log-bin.000001 |       154 |
+----------------------+-----------+

# 查看当前日志，记录的事件，最新截止点在哪
mysql> show master status;

mysql> show master status;
+----------------------+----------+--------------+------------------+-------------------+
| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+----------------------+----------+--------------+------------------+-------------------+
| mysql-log-bin.000001 |      154 |              |                  |                   |
+----------------------+----------+--------------+------------------+-------------------+

```



### 刷新新日志文件

```bash
一般用于数据库恢复，数据库重置时，才会用到。

除非你已经做好了全量备份，次日新增数据时，重新记录新的binlog也行。

flush logs; 不能随便敲
```



### 查看当前mysql用哪个日志文件

```bash
# 查看当前mysql，正在用的哪个binlog日志文件
show master status;


# 显示mysql所有的binlog记录
# 你当前数据库实例，所有的数据变化，分散记录再了这些日志文件中
show binary logs;

```



### 查看binlog日志

```bash
# 1. binlog是二进制，人类看不懂的
# 2. 基于mysqlbinlog命令，解读为普通的SQL文件即可

mysqlbinlog /mysql_log/log_bin_3306/mysql-log-bin.000003 > /tmp/mysql-000003.txt


# 解密当前binlog，查看具体的SQL
# 基于base64算法，按行解密binlog
#  -vv 显示日志的详细程度
mysqlbinlog --base64-output=decode-rows -vv /mysql_log/log_bin_3306/mysql-log-bin.000003 > /tmp/decode-mysql-log.txt

```

 

### binlog日志截取和恢复



```bash
binlog这一块的学习

1. binlog如何开启
2. binlog如何查看，多个命令
3. 如何查看binlog的事件

4. binlog就是记录你增删改查操作的一个日志

5.基于binlog实现数据的恢复 


6. 直接基于mysql的 binlog  pos值去恢复，目前生产级别，最新的玩法，

GTID日志玩法

将你每一个 事务操作，提交为一个 基于uuid的 事务版本号

v1 insert 
v2 insert
v3 insert 
v4  insert  
再也不用你关心，这俩参数怎么玩了
--start-position=381 --stop-position=752



mysqlbinlog --start-position=381 --stop-position=752 mysql-log-bin.000004 > /tmp/restore-lol.sql
```



模拟练习

```bash
1.再来一次，建库，建表，删表，恢复数据

# 1.刷新日志，从头来
flush logs;

# 2.建库建表
# 展示状态
mysql> show master status;
# 创建库
mysql> create database lol01;
# 创建表
mysql> use lol01;

mysql> show master status;
# 展示事务
mysql> show binlog events in 'mysql-log-bin.000004';
# 插入数据
mysql> insert into tanke values(666),(777),(888);
# 删除表
mysql> drop table tanke;


# 根据events位置从建表开始恢复
# 基于mysqlbinlog命令，截取binlog日志，拿到这个区间的sql

# --start-position 从建表开始 316
# --stop-position  到删表之前结束 751

mysqlbinlog  --start-position=316 --stop-position=751 /mysql_log/log_bin_3306/mysql-log-bin.000004 > /tmp/huifu-tb04.txt


# 恢复时要进入数据库，暂停事务的记录，导入数据，再开启记录

# 暂停事务记录
mysql> set sql_log_bin=0;

# 恢复数据
mysql> source /tmp/huifu-tb04.txt;

# 查看数据
mysql> select * from lol01.tanke;

# 开启事务记录
mysql> set sql_log_bin=1;
```



### 开启GTID

```bash
1. 修改配置文件，在my.cnf

2. 具体配置如下
[mysqld]
gtid-mode=ON
enforce-gtid-consistency=true
log-slave-updates=ON

server_id=100
log_bin=/mysql_log/log_bin_3306/mysql-log-bin
character_set_server=utf8mb4
port=3306
user=mysql
basedir=/opt/mysql
datadir=/linux0224/mysql_3306/
socket=/tmp/mysql.sock

[mysql]
socket=/tmp/mysql.sock

# 重启mysql，配置生效，加载gtid功能
systemctl restart mysqld


# 查看关于gtid的mysql内置变量
show variables like '%GTID%';

mysql> show variables like "%GTID%";
+----------------------------------+-----------+
| Variable_name                    | Value     |
+----------------------------------+-----------+
| binlog_gtid_simple_recovery      | ON        |
| enforce_gtid_consistency         | ON        |
| gtid_executed_compression_period | 1000      |
| gtid_mode                        | ON        |
| gtid_next                        | AUTOMATIC |
| gtid_owned                       |           |
| gtid_purged                      |           |
| session_track_gtids              | OFF       |
+----------------------------------+-----------+
8 rows in set (0.01 sec)


```



### GTID恢复数据

```bash
--skip-gtids
加上这个参数，基于gtid的恢复，不会报错


如果我们是要恢复数据到源数据库或者和源数据库有相同 GTID 信息的实例，那么就要使用该参数。如果不带该参数的话，是无法恢复成功的。
因为包含的 GTID 已经在源数据库执行过了，根据 GTID 特性，一个 GTID 信息在一个数据库只能执行一次，所以不会恢复成功。


# 注意参数的添加，--skip-gtids ，不加mysql会进行gtid记录的幂等性检查，导入sql会报错
# 导出从建库，创建数据，的所有gtid记录，不需要记录pos了


# 基于解密参数，看看日志的可阅读性，在干啥

# 解析 binlog mysql-log-bin.000015 
# 截取事务号
mysqlbinlog  --skip-gtids  --include-gtids='187299d4-0e2b-11ed-8b0c-000c29463bc7:2-3' mysql-log-bin.000015  > /opt/huifu_xixi_table.txt


# 关闭binlog记录
mysql> set sql_log_bin=0;

#恢复
mysql> source /opt/huifu_xixi_table.txt

#开启binlog记录
mysql> set sql_log_bin=1;



# 其实区别就是 之前是基于 --start-pos 以及--stop-pos去决定，截取的日志区间，提取SQL

# 而现在直接基于GTID的号码，即可实现，截取数据区间。完成恢复，且更强大

```



### 常见备份方式

#### 全量备份

```bash
方案1：逻辑备份
基于mysqldump命令，使用-A参数，全部的库表备份 ,导出来的数据是一堆SQL语句，兼容性很强
--all-database 所有的库表
 
# -F 参数是干啥的？
# 全量备份的命令
# 日常人类日常思维，按天作为每一天的结束
# 数据备份，24h备份，每天全量备份


mysqldump -uroot -plinux3306 -S /data/3306/mysql.sock -F -A  |gzip >/server/backup/mysqlbak_$(date+%F).sql.gz



方案2，直接物理备份
ls /linux0224/mysql_3306/

cp
tar
rsync


```



#### 全量备份的参数

```bash
# 踩坑记录，不要携带GTID的数据导出
--set-gtid-purged=OFF


-F 备份数据且刷新binlog

--master-data=2

```



#### 正确逻辑备份玩法

```bash
mysqldump -uroot -plinux3306  --set-gtid-purged=OFF  -A -F --master-data=2  > /tmp/no-gtid-all-db-flush-log.sql
```



#### 解读参数--set-gtid-purged=OFF

```bash
1. 机器A mysqldump 导出数据，不用该参数，导出的SQL数据，携带当前机器A的 binlog历史记录
且机器B导入该SQL的话，也不会再新记录binlog

2. 机器A mysqldump导出数据携带该参数，导出的只有SQL数据，且不包含GTID信息
这样，新机器B导入该SQL数据，就会重新自己记录binlog 事务记录。

```



### 模拟实战

```bash
# 先刷新日志
mysql> flush logs;

# 查看binlog日志信息
mysql> show binlog events in 'mysql-log-bin.000007';

# 建库
mysql> create database chifan;

# 建表
create table chifan.chaocai(name char(50));

# 插入数据
mysql> insert into chaocai values('小炒肉'),('回锅肉'),('外婆菜');

mysql> show binlog events in "mysql-log-bin.000007";
+----------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
| Log_name             | Pos | Event_type     | Server_id | End_log_pos | Info                                                              |
+----------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+
| mysql-log-bin.000007 |   4 | Format_desc    |       100 |         123 | Server ver: 5.7.28-log, Binlog ver: 4                             |
| mysql-log-bin.000007 | 123 | Previous_gtids |       100 |         194 | fc374b4c-8a4a-11ef-9205-000c29b496ad:1-5                          |
| mysql-log-bin.000007 | 194 | Gtid           |       100 |         259 | SET @@SESSION.GTID_NEXT= 'fc374b4c-8a4a-11ef-9205-000c29b496ad:6' |
| mysql-log-bin.000007 | 259 | Query          |       100 |         359 | create database chifan                                            |
| mysql-log-bin.000007 | 359 | Gtid           |       100 |         424 | SET @@SESSION.GTID_NEXT= 'fc374b4c-8a4a-11ef-9205-000c29b496ad:7' |
| mysql-log-bin.000007 | 424 | Query          |       100 |         544 | use `chifan`; create table chifan.chaocai(name char(50))          |
| mysql-log-bin.000007 | 544 | Gtid           |       100 |         609 | SET @@SESSION.GTID_NEXT= 'fc374b4c-8a4a-11ef-9205-000c29b496ad:8' |
| mysql-log-bin.000007 | 609 | Query          |       100 |         683 | BEGIN                                                             |
| mysql-log-bin.000007 | 683 | Table_map      |       100 |         737 | table_id: 109 (chifan.chaocai)                                    |
| mysql-log-bin.000007 | 737 | Write_rows     |       100 |         805 | table_id: 109 flags: STMT_END_F                                   |
| mysql-log-bin.000007 | 805 | Xid            |       100 |         836 | COMMIT /* xid=49 */                                               |
+----------------------+-----+----------------+-----------+-------------+-------------------------------------------------------------------+


# 全量备份语句
mysqldump -uroot -plinux3306 -F -A --master-data=2 --single-transaction --max_allowed_packet=64M -R -E  > /tmp/full_db_$(date +%F).sql


# 查看新的binlog是否已经自动刷新
mysql> show master status;
+----------------------+----------+--------------+------------------+------------------------------------------+
| File                 | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |
+----------------------+----------+--------------+------------------+------------------------------------------+
| mysql-log-bin.000008 |      194 |              |                  | fc374b4c-8a4a-11ef-9205-000c29b496ad:1-8 |
+----------------------+----------+--------------+------------------+------------------------------------------+


# 再次插入数据
mysql> insert into chifan.chaocai values('宫保鸡丁'),('鱼香肉丝'),('麻婆豆腐');

mysql> select *  from chifan.chaocai;
+--------------+
| name         |
+--------------+
| 小炒肉       |
| 回锅肉       |
| 外婆菜       |
| 宫保鸡丁     |
| 鱼香肉丝     |
| 麻婆豆腐     |
+--------------+

# 删掉表
mysql> drop table chifan.chaocai;


# 先全量恢复，使用已经记录下来的sql文件
/tmp/full_db_2024-10-30.sql

mysql> source /tmp/full_db_2024-10-30.sql;

mysql> select *  from chifan.chaocai;
+-----------+
| name      |
+-----------+
| 小炒肉    |
| 回锅肉    |
| 外婆菜    |
+-----------+


# 增量binlog事务截取语句
mysqlbinlog --skip-gtids --include-gtids='fc374b4c-8a4a-11ef-9205-000c29b496ad:9' /mysql_log/log_bin_3306/mysql-log-bin.000008  > /tmp/restore_chaocai_db.sql


# 再使用binlog进行增量恢复
mysql> set sql_log_bin=0;

mysql> source /tmp/restore_chaocai_db.sql;

mysql> set sql_log_bin=1;

mysql> select *  from chifan.chaocai;
+--------------+
| name         |
+--------------+
| 小炒肉       |
| 回锅肉       |
| 外婆菜       |
| 宫保鸡丁     |
| 鱼香肉丝     |
| 麻婆豆腐     |
+--------------+


完成结束
```





## 06-Xtrabackup工具

### 安装xtrabackup工具

```bash
yum install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL -y

# 下载软件且安装
wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.9/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.9-1.el7.x86_64.rpm

yum localinstall percona-xtrabackup-24-2.4.9-1.el7.x86_64.rpm -y


```



### 全量备份

```bash
0. 给你的机器，设置基于GTID的模式运行

1. 基于命令 ，全量备份命令
# 和mysqldump很像，链接实例，备份数据

innobackupex --user=root  --password=linux3306  -S /tmp/mysql.sock  /xtrabackup_data/ 



# 不要该工具自带的时间戳信息
--no-timestamp 

# 自己指定备份的时间目录 
innobackupex --no-timestamp   --user=root   --password=linux3306  -S /tmp/mysql.sock  /xtrabackup_data_no_time/full_3306_db_$(date +%F)/

```



### 恢复该全量备份的数据

```bash
1. 挪走自带的数据，用mv替代rm

mkdir /opt/3306_db_backup

mv /linux0224/mysql_3306/* /opt/3306_db_backup/


2.尝试用xtrabackup命令恢复

恢复的思路其实，把备份的数据，原封不动，再放回mysql  datadir下

3. 基于xtraback命令的参数，对默认所有的未提交事务，确保数据一致性
# 操作备份的数据即可
innobackupex --apply-log     /xtrabackup_data_no_time/full_3306_db_2024-10-30/

4. 此时就可以直接恢复数据了
# innobackupex > rsync 数据拷贝回去
innobackupex --defaults-file=/etc/my.cnf --copy-back --rsync  /xtrabackup_data_no_time/full_3306_db_2024-10-30/

4.1 重新授权给mysql
[root@tech-db-51 /linux0224/mysql_3306]#chown -R mysql.mysql ./*
```



### 增量备份

```bash
# 进行次日的增量备份，生成增量数据目录
# --incremental-basedir  以哪个目录为基础数据目录，然后进行增量备份 
# --incremental  增量备份的数据，放到哪

innobackupex --defaults-file=/etc/my.cnf --user=root --password=linux3306 --socket=/tmp/mysql.sock --no-timestamp --incremental-basedir=/xtrabackup_0224/full_3306_db_2022-08-10  --incremental   /xtrabackup_0224/incr_1_2022-08-11


```



### 实践任务

```bash
完成演练目标

周日full + 周一inc1 + 周二inc2 + 周三 inc3 

注意命令细节即可，最后恢复时，需要先合并多个增量备份的日志，然后再统一恢复完整的数据。

# 1.先全量备份
innobackupex --no-timestamp   --user=root   --password=linux3306  -S /tmp/mysql.sock  /xtrabackup_0224/full_3306_db_$(date +%F)/

# 2.模拟次日10-31的增量写入
mysql> create database db_10_31;

# 3.进行次日的增量备份，生成增量数据目录
# --incremental-basedir  以哪个目录为基础数据目录，然后进行增量备份 
#  --incremental  增量备份的数据，放到哪

innobackupex --defaults-file=/etc/my.cnf --user=root --password=linux3306 --socket=/tmp/mysql.sock --no-timestamp --incremental-basedir=/xtrabackup_0224/full_3306_db_2024-10-30  --incremental /xtrabackup_0224/incr_1_2024-10-31 

# 4.进行11-1的增量备份，写入数据，模拟当天的数据增量
mysql> create database db_11_1;

# 5.对11-1的数据，进行增量备份
innobackupex --defaults-file=/etc/my.cnf --user=root --password=linux3306 --socket=/tmp/mysql.sock --no-timestamp --incremental-basedir=/xtrabackup_0224/incr_1_2024-10-31  --incremental /xtrabackup_0224/incr_1_2024-11-1



```



### 数据恢复

```bash
# 先模拟删数据，全部删除，反正有全量备份

mkdir -p /tmp/test_xtrabackup_db/
mv /linux0224/mysql_3306/*  /tmp/test_xtrabackup_db/

# 1. 明确了，目前可以恢复  10-30  到 11-1的数据，

# 2. 注意11-2的数据，再binlog里，找binlog在哪

# 3.开始合并增量日志
大体思路，每一个备份的数据，都要用该参数 --apply-log ，提交，回滚事务，确保数据一致性
--redo-only    只要不是最后一次合并，都要加这个参数

# 先处理10-30全量数据
innobackupex --apply-log  --redo-only /xtrabackup_0224/full_3306_db_2024-10-30

# 合并增量10-31，到全量数据
# --incremental-dir 填入增量的数据目录    写入 全量数据目录
innobackupex --apply-log   --redo-only --incremental-dir=/xtrabackup_0224/incr_1_2024-10-31 /xtrabackup_0224/full_3306_db_2024-10-30

# 合并11-1的增量数据
innobackupex --apply-log   --redo-only --incremental-dir=/xtrabackup_0224/incr_1_2024-11-1 /xtrabackup_0224/full_3306_db_2024-10-31

# 最后对full数据 一致性校验确认，提交事务
innobackupex --apply-log /xtrabackup_0224/full_3306_db_2024-10-30

# 基于最终的全量数据，恢复
innobackupex --copy-back /xtrabackup_0224/full_3306_db_2024-10-30 

cd /linux0224/mysql_3306 && chown -R mysql.mysql ./*

# 差最后一个11-2增量写入
# 基于mysqlbinlog  基于GTID的号码，恢复数据  db_11-2

mysqlbinlog --skip-gtids --include-gtids='9945ceea-1883-11ed-b2b4-000c29463bc7:3'      /mysql_log/log_bin_3306/mysql-log-bin.000013  > /tmp/db_11_2.sql

# 恢复该导出的SQL文件
mysql> set sql_log_bin=0;
mysql> source /tmp/db_11_2.sql;
mysql> set sql_log_bin=1;



```







## 07-主从复制



### 1. 主从复制实践

#### 准备三个机器

```bash
db-51
db-52
db-53


1. 三台机器的 主机id不一样

server_id 务必要区分开

2. 主从复制

master 做 binlog记录


slave  1  无需开启binlog

slave  2  无需开启binlog
```



##### 初始化机器，安装mysql

```bash
打包软件发送到db-51，52，53

# 解压安装包
tar -zxf mysql-5.7.28-linux-glibc2.12-x86_64.tar.gz 

# 创建软连接
ln -s /opt/mysql-5.7.28-linux-glibc2.12-x86_64 /opt/mysql

# 配置PATH
echo "export PATH=$PATH:/opt/mysql/bin" >> /etc/profile
source /etc/profile

# 删除mariadb的依赖，删除默认配置文件
yum remove mariadb-libs.x86_64  -y
rm -f /etc/my.cnf

# 装mysql5.7特有的依赖包
yum install libaio-devel -y

# 创建数据目录，
# 准备mysql的数据目录，授权用户
useradd -s /sbin/nologin -M mysql


mkdir -p /data/mysql_3306/
mkdir -p /var/log/mysql/
# 只有51master机器需要binlog目录
mkdir -p /binlog/
chown -R mysql.mysql  /data/  /var/log/mysql/  /binlog/

# 初始化
mysqld --initialize-insecure --user=mysql --basedir=/opt/mysql --datadir=/data/mysql_3306/

# 启动脚本
cp /opt/mysql/support-files/mysql.server /etc/init.d/mysqld

systemctl daemon-reload 
systemctl restart mysqld
systemctl status mysqld

# mysql改密码
mysql -uroot -p

set password for root@localhost = password('linux3306');
```



##### db-51

```bash
cat > /etc/my.cnf<<EOF
[mysqld]
user=mysql
datadir=/data/mysql_3306
basedir=/opt/mysql/
socket=/tmp/mysql.sock
port=3306
log_error=/var/log/mysql/mysql.err
server_id=51
log_bin=/binlog/mysql-bin
character_set_server=utf8mb4
[mysql] 
socket=/tmp/mysql.sock
[client] 
socket=/tmp/mysql.sock
EOF
```



##### db-52

```bash
cat > /etc/my.cnf<<EOF
[mysqld]
user=mysql
datadir=/data/mysql_3306
basedir=/opt/mysql/
socket=/tmp/mysql.sock
port=3306 
log_error=/var/log/mysql/mysql.err 
server_id=52
character_set_server=utf8mb4
[mysql] 
socket=/tmp/mysql.sock
[client] 
socket=/tmp/mysql.sock 
EOF
```



##### db-53

```bash
cat > /etc/my.cnf<<EOF
[mysqld]
user=mysql
datadir=/data/mysql_3306
basedir=/opt/mysql/
socket=/tmp/mysql.sock
port=3306 
log_error=/var/log/mysql/mysql.err 
server_id=53
character_set_server=utf8mb4
[mysql] 
socket=/tmp/mysql.sock
[client] 
socket=/tmp/mysql.sock 
EOF
```



#### db-51主库操作

##### 备份主库数据，发给slave

```bash
关于确保导出的数据，一致性的问题

1. 全库锁表
# 直接再mysql里执行，是对当前mysql会话生效
flush tables with read lock; # 给全库的表上锁
# 写入配置文件，重启mysql，确保全局上锁


2. 基于如下命令，确保导出的数据，完整的

# 备份命令
# -A 备份所有库表
# --single-transaction，给所有数据库加锁，防止数据写入，导致备份错误
# --master-data=2 将binlog的信息以注释形式备份
# -R 导出mysql自定义函数
# -E 导出events事件 
# --triggers 导出所有数据表的触发器



- 创建数据

- 创建一个复制的账号

1.创建复制用户
# 复制账号 repl_0224  密码 repl_pwd  

mysql -uroot -plinux3306 -e "grant replication slave on *.* to 'repl_0224'@'10.0.0.%' identified by 'repl_pwd'"

2.查看用户
mysql -uroot -plinux3306 -e "select user,host,plugin from mysql.user"

3.查看权限
mysql -uroot -plinux3306 -e "show grants for repl_0224@'10.0.0.%'"


# 备份全量数据
mysqldump -uroot -plinux3306 -A --master-data=2 --single-transaction -R -E --triggers --max_allowed_packet=64M >  /data/full.sql

# 主库的数据 发给slave
for i in 52 53;do scp /data/full.sql 10.0.0.$i:/opt/;done

```



#### Slave从库操作

```bash
# 先导入主库数据
mysql -u root -plinux3306 < /opt/full.sql

# 先查看当前的机器的 复制状态
mysql> show slave status;

# 修改主从关系参数
change master to 
master_host='10.0.0.51',
master_port=3306,
master_user='repl_0224',
master_password='repl_pwd',
master_log_file='mysql-bin.000001',
master_log_pos=449,
master_connect_retry=10;

# 再次查看复制关系。只有start slave后才能看到复制关系
show slave status\G;

# 只有看到如下2个现成，状态是YES才能确保 复制正常
             Slave_IO_Running: No
            Slave_SQL_Running: No
            
# 启动slave复制
start slave;

```



### 2.主从复制原理

```


```



![image-20241031000125950](F:\学习笔记\devops\learn_info\pic\image-20241031000125950.png)



#### 主库的线程的名字，作用

```bash
# 主库开启俩线程，用于发送binlog，分别给 52  53机器

# 具体详解

binlog_dump_thread

1. Master has sent all binlog to slave  传送主库binlog发给slave进行同步

2. waiting for more updates
```



#### 从库的线程的名字，作用

```bash
# 第一个线程的详解

- Slave_IO_Running: Yes   

- IO线程 连接主库dump线程，请求master的binlog，接收master的日志，存储到从库本地的日志（relay-log）

- Waiting for master to send event 



# 第二个线程的详解

- Slave_SQL_Running: Yes

- SQL线程 回放relaylog，写入slave机器数据

- Slave has read all relay log; waiting for more updates

```



#### 查看从库的复制状态日志

![image-20241031001547421](F:\学习笔记\devops\learn_info\pic\image-20241031001547421.png)



#### 主从涉及的文件和命令

##### 主库

```bash
关乎于主从复制，binlog

把二进制日志，记录了一堆SQL变动的事件，

show master status;  看最新的binlog日志

show binary logs; 显示历史所有的二进制日志

show binlog events in '日志名;'

mysql> show variables like '%log_bin%';


```



##### 从库

```bash
# 中继日志 relay-log

通过变量查询，所有的中继日志相关的信息，名字，路径
mysql> show variables like '%relay%';

#  主库的binlog  >  slave 中继日志 
#  主库的binlog > 放到slave再来一遍（中继日志）

# 日志都可以基于mysqlbinlog进行解析

```



### 3.GTID的主从复制

```bash
# 清空52，53数据

cd /data/mysql_3306
rm -rf *


# 开启GTID，修改配置文件，增加如下参数
cat /etc/my.cnf

binlog_format=row
gtid-mode=on 
enforce-gtid-consistency=true
log-slave-updates=1

# 重启mysql
systemctl restart mysqld

# 验证2个节点是否 支持GTID
show variables like '%GTID%';


# 修改2个slave的主从命令，建立主从关系

# 最终目标，是确保2个slave是基于GTID的复制
# 基于如下命令，基于GTID的复制关系建立
# 自动基于GTID去判断 数据起始点。

change master to master_host='10.0.0.51', master_user='repl_0224', master_password='repl_pwd' , MASTER_AUTO_POSITION=1;

# 开启复制功能
start slave;

# 检查slave复制关系
show processlist; 

show slave status;

# 还有就是去直接看slave的中继日志信息
cat /data/mysql_3306/relay-log.info


```



#### 基于pos值的主从复制更新为GTID

```bash
# 1.先停止slave，以及停止mysql服务
systemctl stop mysqld

stop slave;

# 2.更新主库和从库的配置文件添加gtid的参数
binlog_format=row
gtid-mode=on 
enforce-gtid-consistency=true
log-slave-updates=1

systemctl restart mysqld

show variables like '%GTID%';

```



## 08-高可用MHA

### 从库只读db-52,db53

```bash
# 实现，从库的只读效果查看


# 1.创建普通用户，让从库链接
# 一定要再51机器上执行，对所有目标机器生效
# slave 1 slave 2 应该提供完全一致的服务器，账户也是
# 51机器执行

grant select  on db0224.* to dev0224@'10.0.0.%' identified by 'dev0224';
=============================================================================

# 先用root账户，登录 52,53机器，设置当前实例的 全局读锁

mysql> show variables like 'read_only%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| read_only     | OFF   |
+---------------+-------+
1 row in set (0.00 sec)

# 用root设置全局读锁

mysql> set global read_only=1;
Query OK, 0 rows affected (0.00 sec)

mysql> show variables like 'read_only%';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| read_only     | ON    |
+---------------+-------+
1 row in set (0.00 sec)

=============================================================================

# 分别用两个普通用户，登录具体的 从库实例，查看权限操作

mysql -udev0224 -pdev0224 -h10.0.0.52 -P3306

mysql -udev0224 -pdev0224 -h10.0.0.53 -P3306


```



### mha架构部署

#### 1.所有节点软连接设置

MHA工具会检测mysql命令，这里还需要加软连接

```bash
ln -s /opt/mysql/bin/mysqlbinlog /usr/bin/mysqlbinlog

ln -s /opt/mysql/bin/mysql /usr/bin/mysql



# 用如下命令验证
which mysqlbinlog

which mysql
```



#### 2.所有节点执行，全部免密通信

```bash
yum install sshpass -y

ssh-keygen
sshpass -p '123123' ssh-copy-id 10.0.0.51 -o StrictHostKeyChecking=no
sshpass -p '123123' ssh-copy-id 10.0.0.52 -o StrictHostKeyChecking=no
sshpass -p '123123' ssh-copy-id 10.0.0.53 -o StrictHostKeyChecking=no

# 验证通信
for i in 51 52 53;do ssh root@10.0.0.$i "hostname;echo '我是傻逼'";done
```



#### 3.所有节点安装MHA-node

```bash
mha-node软件，--mha-manage通信

# mha perl语言开发的
# 1.先安装依赖环境

yum install  -y perl-DBD-MySQL -y


# 2.安装软件
yum localinstall mha4mysql-node-0.58-0.el7.centos.noarch.rpm -y
```



#### 4.db-53安装MHA-Manager

MHA管理节点可以装在任何节点，这里就给安装到了`slave03 节点`

因为Manager管理节点，通过ssh检测mysql集群，如果`master`节点服务器宕机，或者网络故障，MHA也无法完成故障切换了。

**因此mha-manager不能装在`master节点`**

```bash
yum install epel-release -y

yum install  -y perl-DBD-MySQL perl-Config-Tiny perl-Log-Dispatch perl-Parallel-ForkManager perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker perl-CPAN perl-Time-HiRes 


yum localinstall -y mha4mysql-manager-0.58-0.el7.centos.noarch.rpm


```



#### 5.所有节点创建mha用户

```bash
mha命令，脚本，通过这个用户，检测 所有机器的 主从复制状态

# db-51执行即可

mysql> 
mysql> grant all privileges on *.* to mha@'%' identified by 'mha0224';
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)
```



#### 6.创建db-53的manager配置文件

```bash
mkdir -p /etc/mha           #<==在/etc下创建mha目录。
mkdir -p /var/log/mha/app1  #<==在/etc下创建mha目录。
```



mysql -uroot -plinux3306 -e "grant replication slave on *.* to 'repl_0224'@'10.0.0.%' identified by 'repl_pwd'"

```bash
cat > /etc/mha/app1.cnf << 'EOF'
[server default]
manager_log=/var/log/mha/app1/manager.log
manager_workdir=/var/log/mha/app1.log
master_binlog_dir=/mysql_binlog/
# 该脚本暂时先注释
master_ip_failover_script=/usr/local/bin/master_ip_failover
user=mha
password=mha0224
ping_interval=2
# 填入你当前主从复制，账号密码
repl_user=repl_0224
repl_password=repl_pwd
#  mha 用这个账户，免密登录3个节点机器
ssh_user=root

[server1]
hostname=10.0.0.51
port=3306

[server2]
hostname=10.0.0.52
port=3306

[server3]
hostname=10.0.0.53
port=3306
EOF
```



#### 创建基于VIP的MHA高可用性数据库

只需要修改这个脚本，填入你的网卡环境即可

```bash
创建如下脚本，mha配置文件，会自动调用它，perl语言脚本

/usr/local/bin/master_ip_failover

#!/usr/bin/env perl

use strict;
use warnings FATAL => 'all';

use Getopt::Long;

my (
    $command,          $ssh_user,        $orig_master_host, $orig_master_ip,
    $orig_master_port, $new_master_host, $new_master_ip,    $new_master_port
);

my $vip = '10.0.0.55/24';
# 给网卡添加的别名
my $key = '1';
my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";
my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down";
my $ssh_Bcast_arp="/sbin/arping -I eth0 -c 3 -A 10.0.0.55";

GetOptions(
    'command=s'          => \$command,
    'ssh_user=s'         => \$ssh_user,
    'orig_master_host=s' => \$orig_master_host,
    'orig_master_ip=s'   => \$orig_master_ip,
    'orig_master_port=i' => \$orig_master_port,
    'new_master_host=s'  => \$new_master_host,
    'new_master_ip=s'    => \$new_master_ip,
    'new_master_port=i'  => \$new_master_port,
);

exit &main();

sub main {

    print "\n\nIN SCRIPT TEST====$ssh_stop_vip==$ssh_start_vip===\n\n";

    if ( $command eq "stop" || $command eq "stopssh" ) {

        my $exit_code = 1;
        eval {
            print "Disabling the VIP on old master: $orig_master_host \n";
            &stop_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn "Got Error: $@\n";
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "start" ) {

        my $exit_code = 10;
        eval {
            print "Enabling the VIP - $vip on the new master - $new_master_host \n";
            &start_vip();
            $exit_code = 0;
        };
        if ($@) {
            warn $@;
            exit $exit_code;
        }
        exit $exit_code;
    }
    elsif ( $command eq "status" ) {
        print "Checking the Status of the script.. OK \n";
        exit 0;
    }
    else {
        &usage();
        exit 1;
    }
}

# author: www.yuchaoit.cn

sub start_vip() {
    `ssh $ssh_user\@$new_master_host \" $ssh_start_vip \"`;
}
sub stop_vip() {
     return 0  unless  ($ssh_user);
    `ssh $ssh_user\@$orig_master_host \" $ssh_stop_vip \"`;
}

sub usage {
    print
    "Usage: master_ip_failover --command=start|stop|stopssh|status --orig_master_host=host --orig_master_ip=ip --orig_master_port=port --new_master_host=host --new_master_ip=ip --new_master_port=port\n";
}

```



#### 给当前的主库机器，添加VIP

```bash
# 创建
ifconfig eth0:1 10.0.0.55/24

# 删除
ifconfig eth0:1 del 10.0.0.55

# 停止
ifconfig eth0:1 down
```



#### 7.状态检查db-53

```bash
检测如下MHA运行条件
# mha提供了很方便的脚本，检测你的mha环境搭建情况
- SSH免密登录
- MySQL主从复制

masterha_check_ssh --conf=/etc/mha/app1.cnf 


# 主从检测脚本，会用到mha账号，在三个机器上进行检测登录

# 再检查主从复制状态
masterha_check_repl --conf=/etc/mha/app1.cnf

```



#### 启动MHA程序

```bash
1. 启动mha的管理节点，后台运行即可---用的是 db-53机器

nohup masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf  --ignore_last_failover /var/log/mha/app1/manager.log 2>&1 &

2 .检查MHA是否运行中

masterha_check_status --conf=/etc/mha/app1.cnf
```



#### 故障演练

```bash
期望的结果是
1. 当前环境
db-51    master 

db-52   slave  

db-53    slave  

2. 干掉主库
pkill -9 mysql


2.1 查看VIP的状态，MHA脚本切换VIP到新的主库上，51机器的VIP没了
已确认 51机器的VIP没了


3. 查看主从复制关系
[root@db-53 ~]#mysql -uroot -plinux3306
mysql> show slave status\G

得到结论，MHA自动选举 db-52为新的主库

还得做数据的验证，看看旧的主库51机器的binlog，和52新主库对比
[root@db-51 /mysql_binlog]#mysqlbinlog -vv  mysql-bin.000002 |grep -i 'gtid'


---看52机器


----52机器

SHOW GLOBAL VARIABLES LIKE 'server_uuid';


4.  MHA再发生切换后，该程序会挂掉
也确认了

```



重新做测试配置文件52机器

```
[mysqld]
binlog_format=row
gtid-mode=on
enforce-gtid-consistency=true
log-slave-updates=1

user=mysql
datadir=/data/mysql_3306
basedir=/opt/mysql/
socket=/tmp/mysql.sock
port=3306
log_error=/var/log/mysql/mysql.err
server_id=53
log_bin=/binlog/mysql-bin
read_only=1
character_set_server=utf8mb4

[mysql]
socket=/tmp/mysql.sock
[client]
socket=/tmp/mysql.sock
```



#### 恢复51机器，以及MHA再次做高可用检测

```bash
1. 51机器，直接启动，和新的主库建立复制就行，预测，51机器，是否能看到最新的 52机器的数据

# 1.启动
systemctl start mysqld

# 2. 加入主从
mysql -uroot -plinux3306

change master to master_host='10.0.0.52', master_user='repl_0224', master_password='repl_pwd' , MASTER_AUTO_POSITION=1;


start slave;

show slave status;

```



#### 再次开启mha

```bash
1.添加db-51机器的 配置信息
masterha_conf_host --command=add --conf=/etc/mha/app1.cnf --hostname=10.0.0.51 --block=server1 --params="port=3306"

2.重新检测 ssh，repl
masterha_check_repl --conf=/etc/mha/app1.cnf

masterha_check_ssh --conf=/etc/mha/app1.cnf

3.重新启动即可
nohup masterha_manager --conf=/etc/mha/app1.cnf  --remove_dead_master_conf  --ignore_last_failover /var/log/mha/app1/manager.log 2>&1 &
```

